<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zwift Click - Message Pattern Detector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            background: #fc5200;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        .instructions {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .message-group {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 5px solid #007bff;
        }
        .message-item {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 2px 0;
        }
        .time-diff {
            color: #dc3545;
            font-weight: bold;
        }
        .log {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Zwift Click - Message Pattern Detector</h1>
        
        <div class="instructions">
            <strong>üéØ This test will detect if your buttons send different message patterns!</strong>
            <ol>
                <li>Connect your Zwift Click</li>
                <li>Press the UP/RIGHT button <strong>slowly</strong> 3 times (wait 2 seconds between presses)</li>
                <li>Press the DOWN/LEFT button <strong>slowly</strong> 3 times (wait 2 seconds between presses)</li>
                <li>Watch for message groups - some buttons send 2 messages!</li>
            </ol>
        </div>
        
        <div style="text-align: center;">
            <button id="connect-btn">Connect Zwift Click</button>
            <button id="clear-btn">Clear Data</button>
        </div>

        <h3>üìä Message Groups (Messages within 200ms are grouped):</h3>
        <div id="message-groups"></div>

        <h3>üìù Raw Log:</h3>
        <div id="log" class="log"></div>
    </div>

    <script>
        class ZwiftClickPatternDetector {
            constructor() {
                this.messageGroups = [];
                this.currentGroup = null;
                this.lastMessageTime = 0;
                this.setupEventListeners();
                this.log('üöÄ Pattern Detector Ready');
            }
            
            setupEventListeners() {
                document.getElementById('connect-btn').addEventListener('click', () => this.connect());
                document.getElementById('clear-btn').addEventListener('click', () => this.clearData());
            }
            
            async connect() {
                try {
                    this.log('üîç Searching for Zwift Click...');
                    
                    const device = await navigator.bluetooth.requestDevice({
                        filters: [
                            { namePrefix: 'Zwift Click' },
                            { namePrefix: 'CLICK' }
                        ],
                        optionalServices: [
                            '00000001-19ca-4651-86e5-fa29dcdd09d1',
                            '0000180f-0000-1000-8000-00805f9b34fb'
                        ]
                    });
                    
                    this.log(`üì± Found: ${device.name}`);
                    
                    const server = await device.gatt.connect();
                    const service = await server.getPrimaryService('00000001-19ca-4651-86e5-fa29dcdd09d1');
                    
                    // Get all characteristics
                    const characteristics = await service.getCharacteristics();
                    this.log(`Found ${characteristics.length} characteristics`);
                    
                    // Subscribe to ALL notification characteristics
                    for (const char of characteristics) {
                        if (char.properties.notify) {
                            try {
                                await char.startNotifications();
                                char.addEventListener('characteristicvaluechanged', (event) => {
                                    this.handleData(char.uuid, event.target.value);
                                });
                                this.log(`‚úÖ Subscribed to ${char.uuid}`);
                            } catch (e) {
                                this.log(`Could not subscribe to ${char.uuid}`);
                            }
                        }
                    }
                    
                    // Try different handshakes
                    try {
                        const controlChar = await service.getCharacteristic('00000003-19ca-4651-86e5-fa29dcdd09d1');
                        
                        // Try "RideOn" handshake
                        const handshake1 = new TextEncoder().encode('RideOn');
                        await controlChar.writeValue(handshake1);
                        this.log('‚úÖ Sent RideOn handshake');
                        
                        // Try alternative handshake (0x02, 0x08)
                        setTimeout(async () => {
                            try {
                                const handshake2 = new Uint8Array([0x02, 0x08]);
                                await controlChar.writeValue(handshake2);
                                this.log('‚úÖ Sent alternative handshake [02 08]');
                            } catch (e) {}
                        }, 500);
                        
                    } catch (e) {
                        this.log(`Handshake error: ${e.message}`);
                    }
                    
                    this.log('\nüéÆ NOW PRESS YOUR BUTTONS SLOWLY!');
                    this.log('Press each button with 2-second gaps');
                    
                } catch (error) {
                    this.log(`‚ùå Error: ${error.message}`);
                }
            }
            
            handleData(charUuid, dataValue) {
                const data = new Uint8Array(dataValue.buffer);
                const currentTime = Date.now();
                const hexString = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
                
                // Only process button messages (0x37) and when pressed (byte 2 = 0x00)
                if (data[0] === 0x37 && data[2] === 0x00) {
                    const timeSinceLast = currentTime - this.lastMessageTime;
                    
                    // Log with timing info
                    this.log(`üì¶ ${hexString} (${timeSinceLast}ms since last)`);
                    
                    // Group messages that come within 200ms
                    if (timeSinceLast < 200 && this.currentGroup) {
                        // Add to current group
                        this.currentGroup.messages.push({
                            data: hexString,
                            time: currentTime,
                            timeDiff: timeSinceLast
                        });
                        this.currentGroup.endTime = currentTime;
                    } else {
                        // Start new group
                        if (this.currentGroup) {
                            this.finalizeGroup();
                        }
                        this.currentGroup = {
                            startTime: currentTime,
                            endTime: currentTime,
                            messages: [{
                                data: hexString,
                                time: currentTime,
                                timeDiff: 0
                            }]
                        };
                    }
                    
                    this.lastMessageTime = currentTime;
                    
                    // Auto-finalize group after 300ms
                    setTimeout(() => {
                        if (this.currentGroup && this.currentGroup.endTime === currentTime) {
                            this.finalizeGroup();
                        }
                    }, 300);
                }
            }
            
            finalizeGroup() {
                if (!this.currentGroup) return;
                
                this.messageGroups.push(this.currentGroup);
                this.displayGroups();
                
                // Analyze pattern
                const messageCount = this.currentGroup.messages.length;
                const firstMessage = this.currentGroup.messages[0].data;
                
                if (messageCount === 1) {
                    this.log(`‚úÖ SINGLE MESSAGE GROUP: Likely UP button`);
                } else if (messageCount === 2) {
                    this.log(`‚úÖ DOUBLE MESSAGE GROUP: Likely DOWN button`);
                } else {
                    this.log(`‚ö†Ô∏è ${messageCount} messages in group - unusual`);
                }
                
                this.currentGroup = null;
            }
            
            displayGroups() {
                const container = document.getElementById('message-groups');
                container.innerHTML = '';
                
                this.messageGroups.forEach((group, index) => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'message-group';
                    
                    let html = `<strong>Group ${index + 1} (${group.messages.length} message${group.messages.length > 1 ? 's' : ''}):</strong><br>`;
                    
                    group.messages.forEach((msg, i) => {
                        html += `<div class="message-item">`;
                        html += `  ${msg.data}`;
                        if (msg.timeDiff > 0) {
                            html += ` <span class="time-diff">(+${msg.timeDiff}ms)</span>`;
                        }
                        html += `</div>`;
                    });
                    
                    // Pattern detection
                    if (group.messages.length === 1) {
                        groupDiv.style.borderLeftColor = '#28a745';
                        html += `<strong>‚Üí Pattern: SINGLE (UP?)</strong>`;
                    } else if (group.messages.length === 2) {
                        groupDiv.style.borderLeftColor = '#dc3545';
                        html += `<strong>‚Üí Pattern: DOUBLE (DOWN?)</strong>`;
                    }
                    
                    groupDiv.innerHTML = html;
                    container.appendChild(groupDiv);
                });
            }
            
            clearData() {
                this.messageGroups = [];
                this.currentGroup = null;
                this.lastMessageTime = 0;
                document.getElementById('message-groups').innerHTML = '';
                document.getElementById('log').innerHTML = '';
                this.log('üßπ Data cleared');
            }
            
            log(message) {
                const logElement = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.textContent = `[${timestamp}] ${message}`;
                logElement.appendChild(entry);
                logElement.scrollTop = logElement.scrollHeight;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new ZwiftClickPatternDetector();
        });
    </script>
</body>
</html>